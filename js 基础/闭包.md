```js
var foo = ( function() {
    var secret = 'secret';
    // “闭包”内的函数可以访问 secret 变量，而 secret 变量对于外部却是隐藏的
    return {
        get_secret: function () {
            // 通过定义的接口来访问 secret
            return secret;
        },
        new_secret: function ( new_secret ) {
            // 通过定义的接口来修改 secret
            secret = new_secret;
        }
    };
} () );

foo.get_secret (); // 得到 'secret'
foo.secret; // Type error，访问不能
foo.new_secret ('a new secret'); // 通过函数接口，我们访问并修改了 secret 变量
foo.get_secret (); // 得到 'a new secret'
```
## 定义
内部函数总是可以访问到外部函数中声明的参数和变量，及时在外部函数被返回(被销毁)之后
> 内部函数访问到外部函数的变量是其本身，并非拷贝。在循环中加入闭包需十分注意，循环过程中若有一步过程可缓存变量，函数是 js 中唯一拥有自身作用域的结构
## 作用
1. 读写缓存变量
2. 将变量存储在内存中
## 原理
函数执行分为预编译和执行两个阶段
* 预编译阶段，若发现内部函数使用外部函数的变量，则在内存中创建一个闭包对象，并保存对应的变量值，若已存在闭包，则只需要增加属性值即可
* 执行完成之后，函数执行完后，函数执行上下文会被销毁，函数对闭包的引用对象也会被销毁，但是内部函数还是持有该闭包引用不会被销毁。因此不能滥用闭包，不用时需要将其及时释放，释放时内存函数赋值为 null（这个利用了函数的作用域链特性，函数内部定义的函数会将包含外部的活动对象添加到他的作用域链中，函数执行完毕，气质型的作用域链销毁，但是内部函数的作用域链仍然在引用这个活动对象，所以其多动对象不会被销毁，知道函数被烧毁才被销毁）

## 优点
* 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用
* 避免变量污染全局
* 把变量存到独立的作用域，作为私有成员存在
## 缺点
* 内存消耗可能导致垃圾无法回收，使用不当可能导致内存泄漏
* 处理速度受影响，闭包层级决定了引用外部变量查找是经过的作用域链的长度
* 可能捕获到意外值
